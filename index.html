<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network</title>
    <link rel="shortcut icon" href="neural.png" type="image/png">
    <link rel="stylesheet" href="styles/main.css">
</head>

<body>
    <main>
        <header>
            <p>Изобразите по очереди рисунки с параметром "positive" и "negative". Например веселый и грустный смайлик или галочка и крестик.</p>
            <p>It`s picture...</p>
            <button>positive</button>
            <button>negative</button>
        </header>

        <div class="content">
            <canvas id="canvas" width="500" height="500">Ваш браузер устарел, обновитесь.</canvas>
            <div class="control-panel">
                <div class="slide">
                    <button>Очистить холст</button>
                    <p>Для очистки холста нажмите [C] на клавиатуре.</p>
                </div>
                <div class="slide">
                    <button>Обучить нейросеть</button>
                    <p>Сперва нейросеть нужно обучить. Для этого несколько раз (до 10) изобразите рисунки - сначала с
                        параметром "positive", после с "negative". Для записи данных с холста нажмите [V] на клавиатуре.
                    </p>
                </div>
                <div class="slide">
                    <button>Испытать нейросеть</button>
                    <p>После обучения нейросети можно изображать рисунки и проверять угадывает ли она параметр
                        "positive/negative". Для
                        запуска нейросети нарисуйте картинку и после нажмите [B] на клавиатуре.</p>
                </div>
            </div>
        </div>

        <footer>
            <span>
                This project was developed by <a class="link" target="_blank" href="https://github.com/g-nik1ta">Nikita
                    Gonohov</a>
            </span>
        </footer>
    </main>




    <script src="libs/brain-browser.min.js"></script>
    <script>

        const btns = document.querySelector(".control-panel").querySelectorAll("button");
        for (let i = 0; i < btns.length; i++) {
            btns[i].addEventListener("click", () => {
                btns[i].parentNode.classList.toggle("move");
                btns[i].classList.toggle("moveBtn");
            });
        }

        function DCanvas() {
            const canvas = document.querySelector("#canvas");
            const context = canvas.getContext('2d');
            const pixel = 20;

            let is_mouse_down = false;

            const canvWidth = parseInt(getComputedStyle(canvas).width);
            const canvHeight = parseInt(getComputedStyle(canvas).height);

            this.drawLine = function (x1, y1, x2, y2, color = 'gray') {
                context.beginPath();
                context.strokeStyle = color;
                context.lineJoin = 'miter';
                context.lineWidth = 1;
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.stroke();
            }

            this.drawCell = function (x, y, w, h) {
                context.fillStyle = 'blue';
                context.strokeStyle = 'blue';
                context.lineJoin = 'miter';
                context.lineWidth = 1;
                context.rect(x, y, w, h);
                context.fill();
            }

            this.clear = function () {
                context.clearRect(0, 0, canvWidth, canvHeight);
            }

            this.drawGrid = function () {
                const w = canvWidth;
                const h = canvHeight;
                const p = w / pixel;

                const xStep = w / p;
                const yStep = h / p;

                for (let x = 0; x < w; x += xStep) {
                    this.drawLine(x, 0, x, h);
                }

                for (let y = 0; y < h; y += yStep) {
                    this.drawLine(0, y, w, y);
                }
            }

            this.calculate = function (draw = false) {
                const w = canvWidth;
                const h = canvHeight;
                const p = w / pixel;

                const xStep = w / p;
                const yStep = h / p;

                const vector = [];
                let __draw = [];

                for (let x = 0; x < w; x += xStep) {
                    for (let y = 0; y < h; y += yStep) {
                        const data = context.getImageData(x, y, xStep, yStep);

                        let nonEmptyPixelsCount = 0;
                        for (i = 0; i < data.data.length; i += 10) {
                            const isEmpty = data.data[i] === 0;

                            if (!isEmpty) {
                                nonEmptyPixelsCount += 1;
                            }
                        }

                        if (nonEmptyPixelsCount > 1 && draw) {
                            __draw.push([x, y, xStep, yStep]);
                        }

                        vector.push(nonEmptyPixelsCount > 1 ? 1 : 0);
                    }
                }

                if (draw) {
                    this.clear();
                    this.drawGrid();

                    for (_d in __draw) {
                        this.drawCell(__draw[_d][0], __draw[_d][1], __draw[_d][2], __draw[_d][3]);
                    }
                }

                return vector;
            }

            canvas.addEventListener('mousedown', function (e) {
                is_mouse_down = true;
                context.beginPath();
            })

            canvas.addEventListener('mouseup', function (e) {
                is_mouse_down = false;
            })

            canvas.addEventListener('mousemove', function (e) {
                if (is_mouse_down) {
                    context.fillStyle = 'red';
                    context.strokeStyle = 'red';
                    context.lineWidth = pixel;

                    context.lineTo(e.offsetX, e.offsetY);
                    context.stroke();

                    context.beginPath();
                    context.arc(e.offsetX, e.offsetY, pixel / 2, 0, Math.PI * 2);
                    context.fill();

                    context.beginPath();
                    context.moveTo(e.offsetX, e.offsetY);
                }
            })
        }

        let vector = [];
        let net = null;
        let train_data = [];

        const d = new DCanvas();

        document.addEventListener('keypress', function (e) {
            if (e.key.toLowerCase() == 'c') {
                d.clear();
            }

            if (e.key.toLowerCase() == 'v') {
                vector = d.calculate(true);

                //train
                if (confirm('Positive?')) {
                    train_data.push({
                        input: vector,
                        output: { positive: 1 }
                    });
                } else {
                    train_data.push({
                        input: vector,
                        output: { negative: 1 }
                    });
                }
                console.log('test');
                // console.log(train_data);
            }

            if (e.key.toLowerCase() == 'b') {
                net = new brain.NeuralNetwork();
                net.train(train_data, { log: true });

                const result = brain.likely(d.calculate(), net);
                alert(result);
            }
        });
    </script>

</body>

</html>